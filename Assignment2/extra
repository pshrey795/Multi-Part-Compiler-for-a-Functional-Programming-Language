file: program ()
program: statement program () | ()
statement: formula TERM ()
formula: IF formula THEN formula ELSE formula ()
        | formula IMPLIES formula ()
        | formula AND formula ()
        | formula OR formula ()
        | formula XOR formula ()
        | formula EQUALS formula ()
        | NOT formula ()
        | LPAREN formula RPAREN ()
        | ID ()
        | CONST ()

file: program ()
program: statement program () | ()
statement: formula TERM ()
formula: IF formula THEN formula ELSE formula () | Expression ()
Expression: Term IMPLIES Expression () | Term ()
Term: Term binOp Factor () | Factor()
Factor: NOT Factor() | LPAREN formula RPAREN () | CONST () | ID ()
binOp: AND ()| OR ()| XOR ()| EQUALS ()

all: lexer.lex.sml parser.yacc.*
	mlton a2.mlb

lexer.lex.sml: lexer.lex
	mllex lexer.lex

parser.yacc.*: parser.yacc
	mlyacc parser.yacc

clean:
	rm lexer.lex.* parser.yacc.* a2

fun printLexer ls1 = 
  let
      fun copyString ls1 [] = "EOF]"::ls1
      | copyString ls1 x::ls2 = copyString (x^", ")::ls1 ls2
  in
      print(reverse(copyString [] ls1,[]))
  end 

  fun reverse([],ls)= ls
  | reverse(x::ls1,ls) = reverse(ls1,x::ls)





  structure Token = Tokens
  
  type pos = int
  type svalue = Tokens.svalue
  type ('a,'b) token = ('a,'b) Tokens.token  
  type lexresult = (svalue, pos) token

  val rowNum = ref 1;
  val colNum = ref 1;
  val endOfLine = ref 0;
  val outList = ref (""::[]);
   
  val eof = (printLexer(!outList);fn () => Tokens.EOF(!rowNum, !colNum))
  val error = fn (e, row:int, col:int) => TextIO.output(TextIO.stdOut,"line " ^ (Int.toString row) ^ " " ^ (Int.toString col) ^ ": " ^ e ^ "\n")


%%
%header (functor A2LexFun(structure Tokens:A2_TOKENS));

character=[A-Za-z];
ws = [\ \t ];
%%

"\n"            => (rowNum := !rowNum + 1;endOfLine := yypos;lex());
{ws}+           => (lex());
"NOT"           => (outList:="NOT \"NOT\""::(!outList);colNum := yypos - !(endOfLine);Token.NOT(!rowNum,!colNum));
"AND"           => (outList:="AND" \"AND\""::(!outList);colNum := yypos - !(endOfLine);Token.AND(!rowNum,!colNum));
"OR"            => (outList:="OR \"OR\""::(!outList);colNum := yypos - !(endOfLine);Token.OR(!rowNum,!colNum));
"XOR"           => (outList:="XOR \"XOR\""::(!outList);colNum := yypos - !(endOfLine);Token.XOR(!rowNum,!colNum));
"EQUALS"        => (outList:="EQUALS \"EQUALS\""::(!outList);colNum := yypos - !(endOfLine);Token.EQUALS(!rowNum,!colNum));
"IMPLIES"       => (outList:="IMPLIES \"IMPLIES\""::(!outList);colNum := yypos - !(endOfLine);Token.IMPLIES(!rowNum,!colNum));
"IF"            => (outList:="IF \"IF\""::(!outList);colNum := yypos - !(endOfLine);Token.IF(!rowNum,!colNum));
"THEN"          => (outList:="THEN \"THEN\""::(!outList);colNum := yypos - !(endOfLine);Token.THEN(!rowNum,!colNum));
"ELSE"          => (outList:="ELSE \"ELSE\""::(!outList);colNum := yypos - !(endOfLine);Token.ELSE(!rowNum,!colNum));
";"             => (outList:="TERM \";\""::(!outList);colNum := yypos - !(endOfLine);Token.TERM(!rowNum,!colNum));
"("             => (outList:="LPAREN \"(\""::(!outList);colNum := yypos - !(endOfLine);Token.LPAREN(!rowNum,!colNum));
")"             => (outList:="RPAREN \")\""::(!outList);colNum := yypos - !(endOfLine);Token.RPAREN(!rowNum,!colNum));
"TRUE"          => (outList:="CONST \"TRUE\""::(!outList);colNum := yypos - !(endOfLine);Token.CONST(yytext,!rowNum,!colNum));
"FALSE"         => (outList:="CONST \"FALSE\""::(!outList);colNum := yypos - !(endOfLine);Token.CONST(yytext,!rowNum,!colNum));
{character}+    => (print(yytext^" ");colNum := yypos - !(endOfLine);Token.ID(yytext,!rowNum,!colNum));
.               => (colNum := yypos - !(endOfLine);error(yytext,!rowNum,!colNum);lex());